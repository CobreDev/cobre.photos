---
layout: fullbase.liquid
pagination:
  data: galleries.galleries
  size: 1
  alias: gallery
permalink: "{{ gallery.path }}"
eleventyComputed:
  title: "{{ gallery.short_title | default: gallery.title }} üì∏"
---

<div class="sm:px-20 md:px-32 lg:mx-auto lg:max-w-4xl xl:max-w-6xl mb-4">
  {% if gallery.type == "events" %}
    <a class="text-zinc-500 text-sm no-underline" href="/events">‚Üê Events üìú</a>
  {% else %}
    {% include "_back.liquid" %}
  {% endif %}
  <h1 class="mt-2">{{ gallery.title }}</h1>
  {% if gallery.type == "events" %}
    <small>
      {{ gallery.date | date: "%d.%m.%Y" }} - {{ gallery.location }}
    </small>
  {% endif %}
</div>

{% if gallery.type == "events" %}
  <section class="gallery flex flex-wrap">
    {% assign image_index = 0 %}
    {% for img in gallery.images %}
      {% unless img.url contains '_preview' %}
        <div class="gallery-item relative m-0.5">
          <i class="block bg-zinc-800" style="padding-bottom:{{ img.height | times: 100 | divided_by: img.width }}%"></i>
          <img
            src="{{ img.url | replace: '.jpg', '_preview.webp' }}"
            alt="{{ gallery.title }}"
            loading="lazy"
            class="absolute top-0 w-full h-auto object-cover cursor-pointer"
            onclick="openLightbox('{{ img.url }}', {{ image_index }})"
            data-width="{{ img.width }}"
            data-height="{{ img.height }}" />
        </div>
        {% assign image_index = image_index | plus: 1 %}
      {% endunless %}
    {% endfor %}
  </section>

  <style > :root
  {
    --rowHeight: 120;
  }

  @media (min-width: 640px) {
    :root {
      --rowHeight: 180;
    }
  }

  @media (min-width: 1024px) {
    :root {
      --rowHeight: 250;
    }
  }

  section.gallery::after {
    content: '';
    flex-grow: 999999999;
    /* keeps justification tight */
  }

  .gallery-item {
    flex-grow: 1;
  }
</style>

<script>
    // Store gallery images for navigation
    const galleryImages = [
      {% assign image_index = 0 %}
      {% for img in gallery.images %}
        {% unless img.url contains '_preview' %}
          "{{ img.url }}"{% unless forloop.last %},{% endunless %}
        {% endunless %}
      {% endfor %}
    ];

    function resizeGallery() {
      const items = document.querySelectorAll(".gallery-item img");
      items.forEach(img => {
        const w = parseInt(img.dataset.width, 10);
        const h = parseInt(img.dataset.height, 10);
        const targetHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--rowHeight"), 10);
        const ratioWidth = Math.round((w * targetHeight) / h);
        img.parentElement.style.width = ratioWidth + "px";
        img.parentElement.style.flexGrow = ratioWidth;
      });
    }

    window.addEventListener("resize", resizeGallery);
    window.addEventListener("load", resizeGallery);
</script>{% else %}
<!-- Portfolio Gallery (Tailwind masonry style) -->
<div class="sm:px-20 md:px-32 lg:mx-auto lg:max-w-4xl xl:max-w-6xl">
  <div class="columns-2 xl:columns-3 gap-1 space-y-1">
    {% assign image_index = 0 %}
    {% for img in gallery.images %}
      <img
        src="{{ img.url | replace: '.jpg', '_preview.webp' }}"
        alt="{{ gallery.title }}"
        loading="lazy"
        class="w-full h-auto cursor-pointer hover:brightness-75 transition-filter duration-200"
        onclick="openLightbox('{{ img.url }}', {{ image_index }})" />
      {% assign image_index = image_index | plus: 1 %}
    {% endfor %}
  </div>
</div>

<script>
    // Store gallery images for navigation
    const galleryImages = [
      {% for img in gallery.images %}
        "{{ img.url }}"{% unless forloop.last %},{% endunless %}
      {% endfor %}
    ];
</script>{% endif %}<!-- Enhanced Lightbox with Navigation and Zoom -->
<div
  id="lightbox"
  class="fixed inset-0 bg-black/90 hidden items-center justify-center z-[9999]"
  onclick="handleLightboxClick(event)">

<!-- Navigation Chevrons -->
<button
  id="prevBtn"
  onclick="navigateImage(-1)"
  class="absolute left-4 top-1/2 -translate-y-1/2 z-[10001] bg-black/50 text-white p-3 hover:bg-black/70 transition-colors duration-200"
  style="display: none;">
  <!-- Left Chevron SVG -->
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="square"
    stroke-linejoin="miter">
    <path d="m15 18-6-6 6-6" />
  </svg>
</button>

<button
  id="nextBtn"
  onclick="navigateImage(1)"
  class="absolute right-4 top-1/2 -translate-y-1/2 z-[10001] bg-black/50 text-white p-3 hover:bg-black/70 transition-colors duration-200"
  style="display: none;">
  <!-- Right Chevron SVG -->
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="square"
    stroke-linejoin="miter">
    <path d="m9 18 6-6-6-6" />
  </svg>
</button>

<!-- Top Controls -->
<div class="absolute top-5 right-5 flex gap-2 z-[10000]">
  <a
    id="downloadBtn"
    href="#"
    onclick="downloadImage(event)">
    <button class="bg-white/20 text-white w-10 aspect-square flex items-center justify-center hover:bg-white/30 transition-colors duration-200">
      <!-- Download Icon -->
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="w-5 h-5"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor">
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5 5-5M12 15V3" />
      </svg>
    </button>
  </a>
  <button onclick="closeLightbox()" class="bg-white/20 text-white w-10 aspect-square flex items-center justify-center hover:bg-white/30 transition-colors duration-200">
    <!-- Close Icon -->
    <svg
      xmlns="http://www.w3.org/2000/svg"
      class="w-5 h-5"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor">
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M6 18L18 6M6 6l12 12" />
    </svg>
  </button>
</div>

<!-- Image Container with Zoom -->
<div id="imageContainer" class="relative w-full h-full flex items-center justify-center overflow-hidden">
  <img
    id="lightboxImg"
    src=""
    alt="Expanded image"
    class="max-w-[90vw] max-h-[90vh] object-contain transition-transform duration-200 cursor-grab active:cursor-grabbing"
    style="transform-origin: center;" />
</div>

<!-- Zoom Controls -->
<div class="absolute bottom-5 left-1/2 -translate-x-1/2 flex gap-2 z-[10000]">
  <button onclick="zoomOut()" class="bg-white/20 text-white w-10 aspect-square flex items-center justify-center hover:bg-white/30 transition-colors duration-200">
    <svg
      width="16"
      height="16"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2">
      <circle
        cx="11"
        cy="11"
        r="8" />
      <path d="m21 21-4.35-4.35" />
      <line
        x1="8"
        y1="11"
        x2="14"
        y2="11" />
    </svg>
  </button>
  <button onclick="resetZoom()" class="bg-white/20 text-white px-4 h-10 flex items-center justify-center hover:bg-white/30 transition-colors duration-200 text-sm font-mono">
    <span id="zoomPercentage">100%</span>
  </button>
  <button onclick="zoomIn()" class="bg-white/20 text-white w-10 aspect-square flex items-center justify-center hover:bg-white/30 transition-colors duration-200">
    <svg
      width="16"
      height="16"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2">
      <circle
        cx="11"
        cy="11"
        r="8" />
      <path d="m21 21-4.35-4.35" />
      <line
        x1="11"
        y1="8"
        x2="11"
        y2="14" />
      <line
        x1="8"
        y1="11"
        x2="14"
        y2="11" />
    </svg>
  </button>
</div></div><script>
  let currentImageIndex = 0;
  let currentZoom = 1;
  let isDragging = false;
  let dragStarted = false;
  let startX = 0;
  let startY = 0;
  let translateX = 0;
  let translateY = 0;
  let lastTranslateX = 0;
  let lastTranslateY = 0;
  const DRAG_THRESHOLD = 5; // pixels to move before starting drag

  function openLightbox(src, index = 0) {
    const lb = document.getElementById("lightbox");
    if (!lb) return;
    
    currentImageIndex = index;
    currentZoom = 1;
    translateX = 0;
    translateY = 0;
    lastTranslateX = 0;
    lastTranslateY = 0;
    
    lb.classList.remove("hidden");
    lb.classList.add("flex");
    
    loadImage(src);
    updateNavigationButtons();
    updateZoomPercentage();
    
    // Add keyboard listeners
    document.addEventListener("keydown", handleKeyPress);
  }

  function loadImage(src) {
    const img = document.getElementById("lightboxImg");
    const downloadBtn = document.getElementById("downloadBtn");
    
    // Clear current image
    img.src = "";
    img.style.transform = "scale(1) translate(0px, 0px)";
    
    // Load new image
    img.onload = function() {
      img.style.opacity = "1";
    };
    
    img.style.opacity = "0.5";
    img.src = src;
    downloadBtn.href = src;
  }

  function closeLightbox() {
    const lb = document.getElementById("lightbox");
    if (!lb) return;
    
    lb.classList.remove("flex");
    lb.classList.add("hidden");
    document.getElementById("lightboxImg").src = "";
    document.getElementById("downloadBtn").href = "#";
    
    // Remove keyboard listeners
    document.removeEventListener("keydown", handleKeyPress);
  }

  function navigateImage(direction) {
    if (galleryImages.length <= 1) return;
    
    currentImageIndex += direction;
    
    if (currentImageIndex < 0) {
      currentImageIndex = galleryImages.length - 1;
    } else if (currentImageIndex >= galleryImages.length) {
      currentImageIndex = 0;
    }
    
    // Reset zoom and position
    currentZoom = 1;
    translateX = 0;
    translateY = 0;
    lastTranslateX = 0;
    lastTranslateY = 0;
    
    loadImage(galleryImages[currentImageIndex]);
    updateNavigationButtons();
    updateZoomPercentage();
  }

  function updateNavigationButtons() {
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    
    if (galleryImages.length > 1) {
      prevBtn.style.display = "block";
      nextBtn.style.display = "block";
    } else {
      prevBtn.style.display = "none";
      nextBtn.style.display = "none";
    }
  }

  function handleLightboxClick(event) {
    // Only close if clicking on the lightbox background, not on controls or image
    if (event.target.id === "lightbox" || event.target.id === "imageContainer") {
      closeLightbox();
    }
  }

  function downloadImage(event) {
    event.preventDefault();
    event.stopPropagation(); // Prevent lightbox from closing
    
    const url = document.getElementById("lightboxImg").src;
    const fileName = url.split('/').pop();
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    
    if (isIOS || isSafari) {
      window.open(url, "_blank");
      return;
    }
    
    fetch(url).then(res => res.blob()).then(blob => {
      const blobUrl = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = blobUrl;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      window.URL.revokeObjectURL(blobUrl);
    }).catch(err => console.error("Download failed:", err));
  }

  // Zoom functionality
  function zoomIn() {
    currentZoom = Math.min(currentZoom * 1.5, 5);
    updateImageTransform();
    updateZoomPercentage();
  }

  function zoomOut() {
    currentZoom = Math.max(currentZoom / 1.5, 0.5);
    updateImageTransform();
    updateZoomPercentage();
  }

  function resetZoom() {
    currentZoom = 1;
    translateX = 0;
    translateY = 0;
    lastTranslateX = 0;
    lastTranslateY = 0;
    updateImageTransform();
    updateZoomPercentage();
  }

  function zoomToPoint(clientX, clientY, zoomLevel) {
    const img = document.getElementById("lightboxImg");
    const rect = img.getBoundingClientRect();
    const imgCenterX = rect.left + rect.width / 2;
    const imgCenterY = rect.top + rect.height / 2;
    
    // Calculate offset from center
    const offsetX = (clientX - imgCenterX) / currentZoom;
    const offsetY = (clientY - imgCenterY) / currentZoom;
    
    // Update zoom
    currentZoom = Math.min(Math.max(zoomLevel, 0.5), 5);
    
    // Adjust translation to keep the clicked point under the cursor
    translateX -= offsetX * (currentZoom - 1);
    translateY -= offsetY * (currentZoom - 1);
    
    lastTranslateX = translateX;
    lastTranslateY = translateY;
    
    updateImageTransform();
    updateZoomPercentage();
  }

  function updateZoomPercentage() {
    const percentage = Math.round(currentZoom * 100);
    document.getElementById("zoomPercentage").textContent = percentage + "%";
  }

  function updateImageTransform() {
    const img = document.getElementById("lightboxImg");
    img.style.transform = `scale(${currentZoom}) translate(${translateX}px, ${translateY}px)`;
    
    // Update cursor based on zoom level and drag state
    if (currentZoom > 1) {
      img.style.cursor = isDragging ? "grabbing" : "grab";
    } else {
      img.style.cursor = "zoom-in";
    }
  }

  // Mouse wheel zoom
  document.getElementById("imageContainer").addEventListener("wheel", function(e) {
    e.preventDefault();
    
    const rect = this.getBoundingClientRect();
    const clientX = e.clientX;
    const clientY = e.clientY;
    
    if (e.deltaY < 0) {
      zoomToPoint(clientX, clientY, currentZoom * 1.2);
    } else {
      zoomToPoint(clientX, clientY, currentZoom / 1.2);
    }
  }, { passive: false });

  // Improved mouse drag functionality
  document.getElementById("lightboxImg").addEventListener("mousedown", function(e) {
    e.preventDefault();
    isDragging = true;
    dragStarted = false;
    startX = e.clientX;
    startY = e.clientY;
    
    const handleMouseMove = (e) => {
      if (!isDragging) return;
      
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      
      // Only start dragging if we've moved beyond threshold
      if (!dragStarted && (Math.abs(deltaX) > DRAG_THRESHOLD || Math.abs(deltaY) > DRAG_THRESHOLD)) {
        dragStarted = true;
      }
      
      if (dragStarted && currentZoom > 1) {
        translateX = lastTranslateX + deltaX;
        translateY = lastTranslateY + deltaY;
        updateImageTransform();
      }
    };
    
    const handleMouseUp = (e) => {
      if (isDragging && !dragStarted) {
        // This was a click, not a drag - zoom to click point
        if (currentZoom < 2) {
          zoomToPoint(e.clientX, e.clientY, 2);
        } else {
          resetZoom();
        }
      }
      
      if (dragStarted) {
        lastTranslateX = translateX;
        lastTranslateY = translateY;
      }
      
      isDragging = false;
      dragStarted = false;
      
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
    
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
  });

  // Improved touch support
  let touchStartDistance = 0;
  let touchStartZoom = 1;
  let touchStartX = 0;
  let touchStartY = 0;
  let touchMoved = false;

  document.getElementById("lightboxImg").addEventListener("touchstart", function(e) {
    e.preventDefault();
    touchMoved = false;
    
    if (e.touches.length === 2) {
      // Two finger pinch
      touchStartDistance = getTouchDistance(e.touches[0], e.touches[1]);
      touchStartZoom = currentZoom;
    } else if (e.touches.length === 1) {
      // Single finger
      isDragging = true;
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
  }, { passive: false });

  document.getElementById("lightboxImg").addEventListener("touchmove", function(e) {
    e.preventDefault();
    touchMoved = true;
    
    if (e.touches.length === 2) {
      // Pinch zoom
      const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
      const zoomRatio = currentDistance / touchStartDistance;
      currentZoom = Math.max(0.5, Math.min(5, touchStartZoom * zoomRatio));
      updateImageTransform();
      updateZoomPercentage();
    } else if (e.touches.length === 1 && isDragging && currentZoom > 1) {
      // Single finger pan
      const deltaX = e.touches[0].clientX - touchStartX;
      const deltaY = e.touches[0].clientY - touchStartY;
      
      translateX = lastTranslateX + deltaX;
      translateY = lastTranslateY + deltaY;
      updateImageTransform();
    }
  }, { passive: false });

  document.getElementById("lightboxImg").addEventListener("touchend", function(e) {
    if (!touchMoved && e.changedTouches.length === 1) {
      // Single tap - zoom to point
      const touch = e.changedTouches[0];
      if (currentZoom < 2) {
        zoomToPoint(touch.clientX, touch.clientY, 2);
      } else {
        resetZoom();
      }
    }
    
    if (isDragging) {
      lastTranslateX = translateX;
      lastTranslateY = translateY;
    }
    
    isDragging = false;
    touchMoved = false;
  });

  function getTouchDistance(touch1, touch2) {
    const dx = touch1.clientX - touch2.clientX;
    const dy = touch1.clientY - touch2.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Keyboard navigation
  function handleKeyPress(e) {
    switch(e.key) {
      case "Escape":
        closeLightbox();
        break;
      case "ArrowLeft":
        navigateImage(-1);
        break;
      case "ArrowRight":
        navigateImage(1);
        break;
      case "+":
      case "=":
        zoomIn();
        break;
      case "-":
        zoomOut();
        break;
      case "0":
        resetZoom();
        break;
    }
  }
</script>